<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Type Inference on Ticki&#39;s blog</title>
    <link>http://ticki.github.io/tags/type-inference/</link>
    <description>Recent content in Type Inference on Ticki&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 06 Jun 2016 11:06:21 +0200</lastBuildDate>
    
	<atom:link href="http://ticki.github.io/tags/type-inference/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Lambda crabs (part 2): Region inference is (not) magic.</title>
      <link>http://ticki.github.io/blog/lambda-crabs-part-2-region-inference-is-not-magic./</link>
      <pubDate>Mon, 06 Jun 2016 11:06:21 +0200</pubDate>
      
      <guid>http://ticki.github.io/blog/lambda-crabs-part-2-region-inference-is-not-magic./</guid>
      <description>This post will cover region (lifetime) inference with a mathematical and type theoretical focus.
The problem Inference is a very handy concept. We no longer have to annotate redundant types, which is a major pain point in languages, that lacks of type inference.
Now, we want such an inference scheme for regions as well.
We described the problem of region inference in last post as:
 So, this is just a classical optimization problem:</description>
    </item>
    
  </channel>
</rss>