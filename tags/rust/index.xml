<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rust on Ticki&#39;s blog</title>
    <link>http://ticki.github.io/tags/rust/</link>
    <description>Recent content in Rust on Ticki&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 06 Oct 2016 10:12:22 +0200</lastBuildDate>
    
	<atom:link href="http://ticki.github.io/tags/rust/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Making Terminal Applications in Rust with Termion</title>
      <link>http://ticki.github.io/blog/making-terminal-applications-in-rust-with-termion/</link>
      <pubDate>Thu, 06 Oct 2016 10:12:22 +0200</pubDate>
      
      <guid>http://ticki.github.io/blog/making-terminal-applications-in-rust-with-termion/</guid>
      <description>This post will walk through the basics of implementing a terminal (TTY) application for both new beginners and experienced users of Rust.
Introduction Terminal applications play an important role in many programmers&amp;rsquo; toolchain, from text editors to minigames while your code is compiling. And it&amp;rsquo;s great to know and understand how to make these yourself, so you can create a customized TUI application for your needs.
Escape codes and TTY I/O is messy, but fortunately there are libraries for this.</description>
    </item>
    
    <item>
      <title>A Hoare Logic for Rust</title>
      <link>http://ticki.github.io/blog/a-hoare-logic-for-rust/</link>
      <pubDate>Sat, 24 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://ticki.github.io/blog/a-hoare-logic-for-rust/</guid>
      <description>Lately, I&#39;ve been working on a Hoare-logic-based model of the Rust MIR, which I will introduce in the post. This is a minor step towards a memory model of Rust, and it allows formalization of programs and their behavior.
This project was born out of the effort to formalize the Redox kernel and the ralloc memory allocator as well as coming up with a Rust memory model.
Here I will walk through the techniques, axioms, and transformations in detail.</description>
    </item>
    
    <item>
      <title>Why Rust&#39;s `std::collections` is absolutely fantastic</title>
      <link>http://ticki.github.io/blog/fantastic/</link>
      <pubDate>Wed, 14 Sep 2016 16:07:34 +0200</pubDate>
      
      <guid>http://ticki.github.io/blog/fantastic/</guid>
      <description>My last blog post was about all the short-fallings and problems std::collections has. This post will be about the opposite: all the good things about std::collections and what other languages can learn from Rust.
This post is a part of an on-going series of posts criticizing and praising various parts of Rust.
The philosophy of std::collections Rust has an intentionally small set of collections. This has both advantages and disadvantages.</description>
    </item>
    
    <item>
      <title>A Critique of Rust&#39;s `std::collections`</title>
      <link>http://ticki.github.io/blog/horrible/</link>
      <pubDate>Mon, 12 Sep 2016 22:50:08 +0200</pubDate>
      
      <guid>http://ticki.github.io/blog/horrible/</guid>
      <description>Rust is by far my favorite language, and I am very familiar with it, but there is one aspect that annoys me at times: std::collections, a part of the opt-out standard library.
This post will go through the short-fallings of the API and implementation of std::collections. I&amp;rsquo;ll try to present alternatives and way to improve it.
Update: The title was previously &amp;ldquo;Why std::collections is absolutely horrible&amp;rdquo;. It was in the hope to spark critical discussion, however people were rather annoyed by this title (and I understand why), so I changed it to something less provocative.</description>
    </item>
    
    <item>
      <title>Lambda crabs (part 3): Region-based alias analysis</title>
      <link>http://ticki.github.io/blog/lambda-crabs-part-3-region-based-alias-analysis/</link>
      <pubDate>Wed, 08 Jun 2016 11:24:24 +0200</pubDate>
      
      <guid>http://ticki.github.io/blog/lambda-crabs-part-3-region-based-alias-analysis/</guid>
      <description>In the last post, we saw how to infer regions and their span. In this post, we will cover aliasing and how to ensure guarantees through region analysis.
Aliasing, mutable aliasing, and unsafety. Two pointers are said to be aliased, if they refer to the same object. Alias analysis is essential to program verification, optimizers, and compiler theory.
Alias analysis is the study of which pointers are aliased and, more importantly, which pointers aren&amp;rsquo;t aliased.</description>
    </item>
    
    <item>
      <title>Lambda crabs (part 2): Region inference is (not) magic.</title>
      <link>http://ticki.github.io/blog/lambda-crabs-part-2-region-inference-is-not-magic./</link>
      <pubDate>Mon, 06 Jun 2016 11:06:21 +0200</pubDate>
      
      <guid>http://ticki.github.io/blog/lambda-crabs-part-2-region-inference-is-not-magic./</guid>
      <description>This post will cover region (lifetime) inference with a mathematical and type theoretical focus.
The problem Inference is a very handy concept. We no longer have to annotate redundant types, which is a major pain point in languages, that lacks of type inference.
Now, we want such an inference scheme for regions as well.
We described the problem of region inference in last post as:
 So, this is just a classical optimization problem:</description>
    </item>
    
    <item>
      <title>Lambda crabs (part 1): A mathematical introduction to lifetimes and regions</title>
      <link>http://ticki.github.io/blog/lambda-crabs-part-1-a-mathematical-introduction-to-lifetimes-and-regions/</link>
      <pubDate>Mon, 06 Jun 2016 09:12:56 +0200</pubDate>
      
      <guid>http://ticki.github.io/blog/lambda-crabs-part-1-a-mathematical-introduction-to-lifetimes-and-regions/</guid>
      <description>This post will cover lifetimes and regions in depth, with a focus on the mathematical background of regions. That is, what is a region? What rules do they follow? How does the compiler handle them? And how are they inferred?
Regions and their ordering So, let&amp;rsquo;s briefly investigate what a region is. A region (or in Rust lingo, a lifetime) is a span of some form, e.g. the token stream.</description>
    </item>
    
  </channel>
</rss>