<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Design on Ticki&#39;s blog</title>
    <link>http://ticki.github.io/tags/design/index.xml</link>
    <description>Recent content in Design on Ticki&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://ticki.github.io/tags/design/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>You Are (Probably) Doing Login Systems Wrong</title>
      <link>http://ticki.github.io/blog/you-are-probably-doing-login-systems-wrong/</link>
      <pubDate>Fri, 12 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ticki.github.io/blog/you-are-probably-doing-login-systems-wrong/</guid>
      <description>&lt;p&gt;A thing, most programmers have tried at least once, is login systems. Despite
being seemingly a simple task, it is in fact very hard to do right.&lt;/p&gt;

&lt;p&gt;So, let&#39;s look into, how we can actually do this right.&lt;/p&gt;

&lt;h1 id=&#34;storing-passwords&#34;&gt;Storing passwords&lt;/h1&gt;

&lt;p&gt;Okay, this is common knowledge: Salt and hash your passwords.&lt;/p&gt;

&lt;p&gt;However, it is often done wrong. You&#39;ll see code like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hash(password + salt)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is better than unsalted, unhashed passwords, but it&#39;s far from bruteforce
resistant. Why? Because hashing is cheap. With proper machines, you can do
billions of them in a second. A dictionary attack is piece of cake.&lt;/p&gt;

&lt;p&gt;So how do we solve this? Well, we use a KDF. A KDF (key derivation function)
acts like a slow hash function. A hash function, where calculating takes maybe
100 ms. or more.&lt;/p&gt;

&lt;p&gt;In general, two kinds of KDFs exists, the CPU-based and the CPU-memory hybrids.
The CPU based are still in use, but I don&#39;t recommend using them, as they can
easily be calculated with ASICs. The CPU-memory hybrids requires some amount of
memory for calculating the hash value, often making it substantially harder to
create ASICs.&lt;/p&gt;

&lt;p&gt;For the reasons stated above, I recommend &lt;code&gt;scrypt&lt;/code&gt;, for a modern, well-known
an secure KDF.&lt;/p&gt;

&lt;h1 id=&#34;sessions&#34;&gt;Sessions&lt;/h1&gt;

&lt;p&gt;In general, sessions should be assigned a token by the server. This token is
shared with the client (e.g. through a cookie) as the way to prove, that they
are logged in with a given account to the server.&lt;/p&gt;

&lt;p&gt;There is a few things to keep in mind, though.&lt;/p&gt;

&lt;p&gt;The session token shall have an expiration date, for security reasons.
Furthermore, the session token shall be deactivated when the user logs out.&lt;/p&gt;

&lt;p&gt;One mistake often made in storing the session tokens is to store them in
memory. This is wrong, as it means that crashes or restarts logs every user
out, suspending all sessions. Instead, it ought to be stored in a database,
possibly in a column of the users table.&lt;/p&gt;

&lt;p&gt;Lastly, the session must not be shared through GET or other logged means.
Rather, it should be stored in a cookie or &lt;code&gt;localStorage&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;clientside-hashing&#34;&gt;Client-side hashing&lt;/h1&gt;

&lt;p&gt;A pretty uncommon, but really good practice, is the client-side hashing. It is
supposed act as another layer of security, hiding the password from the server.&lt;/p&gt;

&lt;p&gt;The idea is that the client-side should hash (e.g. &lt;code&gt;scrypt&lt;/code&gt;) the password
before sending it to the server.&lt;/p&gt;

&lt;p&gt;This can seem pretty pointless, as (in the case of the web) the server could
simply change the JavaScript to leak the password, but there is a reason: If
the server-side has a bug that allows to read certain chosen memory locations
(a buffer overflow, for example), it could be exploited to read the plaintext
password.&lt;/p&gt;

&lt;p&gt;Instead, with client-side hashing, it can only read the hashed value. This of
course doesn&#39;t stop the hacker from logging in to the user&#39;s account, but it
stops them from obtaining the potentially reused plain-text password.&lt;/p&gt;

&lt;h1 id=&#34;rate-limiting&#34;&gt;Rate limiting&lt;/h1&gt;

&lt;p&gt;Rate limiting is really, really important, even though it is often understated.
It prevents someone from bruteforcing common passwords.&lt;/p&gt;

&lt;p&gt;But how should the rate limiting work?&lt;/p&gt;

&lt;p&gt;One neat way is the &amp;quot;leaky bucket algorithm&amp;quot;. It works by having requests
&amp;quot;dripping&amp;quot; into a bucket like drops of water. When the leaky bucket is filled,
no more requessts can be made, until the bucket has leaked to empty.&lt;/p&gt;

&lt;p&gt;In less figurative language, you have a counter on every visitor IP address,
which is incremented on every request (e.g. login, create account etc.). When
this counter is above some level (say 5), a timeout is set (e.g. the time when
it expire is set as a field of the user). First when this timeout expires, the
counter resets, and new requests can be made.&lt;/p&gt;

&lt;h1 id=&#34;resetting-accounts&#34;&gt;Resetting accounts&lt;/h1&gt;

&lt;p&gt;Of course a proper system must have the ability to reset accounts. There are
many ways of doing this.&lt;/p&gt;

&lt;p&gt;I would recommend to have the user provide username and E-mail, as it—contrary
to other approaches—does not allow spamming or denial of service attacks. It is
important that you do not reveal whether or not the E-mail matched, as that can
be a breach of privacy of the user (such thing can be used to check if the
E-mail address matched).&lt;/p&gt;

&lt;p&gt;If the E-mail is only going to be used for resetting, I strongly recommend that
you store a fingerprint (e.g. scrypt) of the E-mail address rather than the
plaintext version. This still ensures that you can check if the given E-mail
address of the resetting user matches, without the server side knowing anything
about the address. It prevents the database being misused or sold for spam
purposes, and also helps to protect the user&#39;s identity.&lt;/p&gt;

&lt;p&gt;When the user resets, a token shall be generated. This token is used in a link,
sent to the user through an E-mail. It is important that this token is
sufficiently long, random, and furthermore, that it expires (ideally within only
a few hours).&lt;/p&gt;

&lt;p&gt;Note that upon resetting, the token should removed from the map.&lt;/p&gt;

&lt;h1 id=&#34;other-tips&#34;&gt;Other tips&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Consider implementing a common two-factor key-sharing algorithm, such as
&lt;a href=&#34;https://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm&#34;&gt;TOTP&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;I recommend that changing E-mail and password are done under the &amp;quot;reset
password&amp;quot; formula, such that E-mail confirmation is required.&lt;/li&gt;
&lt;li&gt;It is extremely important that the connection, where the login happens is
secure, for example &lt;code&gt;https&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Well, that&#39;s it.&lt;/p&gt;

&lt;p&gt;You have to be careful about what you do, though. This is a minefield of
vulnerabilities, and you have to be very careful not to introduce subtle bugs
in your code. I recommend that you let somebody other than yourself review your
code, to give you another&#39;s perspective on the code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Portfolio of Logos and Icons</title>
      <link>http://ticki.github.io/blog/portfolio-of-logos-and-icons/</link>
      <pubDate>Mon, 19 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://ticki.github.io/blog/portfolio-of-logos-and-icons/</guid>
      <description>&lt;p&gt;This is a collection of the logos and icons, I created (and used/not drafts) during the last years.&lt;/p&gt;

&lt;h1 id=&#34;opensea&#34;&gt;Open-Sea&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ticki/Open-Sea&#34;&gt;Open Sea&lt;/a&gt; is a dead game project I was working on:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;figure&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ticki/Open-Sea/master/data/graphics/logo_scaled.png&#34; alt=&#34;Open-Sea logo&#34;&gt;&lt;/figure&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;Simple pixel art.&lt;/li&gt;
&lt;li&gt;Stylistic and minimalistic text.&lt;/li&gt;
&lt;li&gt;Simple icon similar to the graphics in the game.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;redox&#34;&gt;Redox&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/redox-os&#34;&gt;Redox&lt;/a&gt; is an operating-system I work on. The icon was one of the first things I contributed to Redox (before code):&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;figure&gt;&lt;img src=&#34;https://rawgit.com/redox-os/assets/master/vectorized_icon.svg&#34; alt=&#34;Redox vectorized icon&#34;&gt;&lt;/figure&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;It is a circle construction formed after an atom.&lt;/li&gt;
&lt;li&gt;The electrons are placed to resemble a sodium atom, which together with e.g. fluorine reacts in a redox reaction.&lt;/li&gt;
&lt;li&gt;It&#39;s SVG!&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;sodium&#34;&gt;Sodium&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/redox-os/sodium&#34;&gt;Sodium&lt;/a&gt; is a text editor I wrote. The logo is&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;img src=&#34;https://raw.githubusercontent.com/redox-os/assets/master/Sodium_logo.png&#34; height=&#34;200&#34; width=&#34;200&#34; /&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;It is based on a basic square with rounded edges (square construction).&lt;/li&gt;
&lt;li&gt;It uses text as a form of background noise.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;xenotime&#34;&gt;XENOTIME&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/neon-sector/xenotime&#34;&gt;XENOTIME&lt;/a&gt; is a game engine, which I created a logo for:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;img src=&#34;https://raw.githubusercontent.com/neon-sector/xenotime/master/res/xenotime/logo.png&#34; height=&#34;200&#34; width=&#34;200&#34; /&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;It is a text-based logo.&lt;/li&gt;
&lt;li&gt;It uses red-black colorscheme because it reflects the colorful game world.&lt;/li&gt;
&lt;li&gt;It preserves simplicity.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;tfs&#34;&gt;TFS&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ticki/tfs&#34;&gt;TFS&lt;/a&gt; is a filesystem I&#39;m working on. The icon is:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;figure&gt;&lt;img src=&#34;https://rawgit.com/ticki/tfs/master/icon.svg&#34; alt=&#34;TFS icon&#34;&gt;&lt;/figure&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;It is a hexagone looking like an isometric projection of a cube, giving it a 3D feel.&lt;/li&gt;
&lt;li&gt;The tetragon gives it a &amp;quot;glassy&amp;quot; feel (looking modern).&lt;/li&gt;
&lt;li&gt;One of my favorite logo creations.&lt;/li&gt;
&lt;li&gt;Just 284 bytes, in total (optimized SVG). Compressed, it is around 100 bytes.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;seahash&#34;&gt;SeaHash&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ticki/tfs/tree/master/seahash&#34;&gt;SeaHash&lt;/a&gt; is a hash function I designed:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ticki/tfs/master/seahash/logo.png&#34; height=&#34;200&#34; width=&#34;200&#34; /&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;Very simple and not so fancy (showing stability and robustness).&lt;/li&gt;
&lt;li&gt;Waves symbolizing the sea and performance.&lt;/li&gt;
&lt;li&gt;Basic monospace font.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;termion&#34;&gt;Termion&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ticki/termion&#34;&gt;Termion&lt;/a&gt; is a terminal manipulation library I wrote:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;a href=&#34;https://rawgit.com/ticki/termion/master/logo.svg&#34;&gt;&lt;figure&gt;&lt;img src=&#34;https://rawgit.com/ticki/termion/master/logo.svg&#34; alt=&#34;Termion logo&#34;&gt;&lt;/figure&gt;&lt;/a&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;It&#39;s animated, which is really cool. Note that in some browsers, the animation doesn&#39;t work in IMG tags, so if it is static, click it.&lt;/li&gt;
&lt;li&gt;The animation gives it an &amp;quot;interactive&amp;quot; feel.&lt;/li&gt;
&lt;li&gt;It uses common terminal colors and font.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;tip-of-the-iceberg&#34;&gt;Tip of the iceberg&lt;/h1&gt;

&lt;p&gt;These are just the ones I used. I&#39;ve created many other drafts and candidates, which I might show in another blog post.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>