<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Design on Ticki&#39;s blog</title>
    <link>http://ticki.github.io/tags/design/index.xml</link>
    <description>Recent content in Design on Ticki&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://ticki.github.io/tags/design/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>An Atomic Hash Table</title>
      <link>http://ticki.github.io/blog/an-atomic-hash-table/</link>
      <pubDate>Sat, 13 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ticki.github.io/blog/an-atomic-hash-table/</guid>
      <description>&lt;script type=&#34;text/javascript&#34;
  src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&#34;&gt;
&lt;/script&gt;

&lt;p&gt;In programs where there is some kind of global state, you will often find
the need for having a key-value map; you could for example imagine keeping some
kind of cache of a bunch of entries from database table. Obviously, you&#39;d just
use a hash table, easy right?&lt;/p&gt;

&lt;p&gt;Not really. Imagine that there is multiple threads. One approach is to wrap it
in a mutex to ensure thread safety, but that would kind of miss the point of
concurrency: It wouldn&#39;t be concurrent, it would just be blocking. So, imagine
we want a non-blocking, truly concurrent hash table. How&#39;d we go about that?&lt;/p&gt;

&lt;p&gt;Several ways to get there exists, unfortunately they all have their trade-offs.
In this blog post, I am going represent the implementation of such table, which
I came up with during the development of &lt;a href=&#34;https://github.com/ticki/tfs&#34;&gt;TFS&lt;/a&gt;.
It is hopefully a sane way to solve the issue with good trade-offs: It has
relatively good consistency guarantees, yet very fast.&lt;/p&gt;

&lt;p&gt;To be clear, if you&#39;re just looking for a quick way to implement this, this is
probably not the post for you. It is somewhat complicated, and you might be
fine with a hash table with locks and striping. However, if you are looking for
something scalable to an arbitrary number of CPU cores, this is for you.&lt;/p&gt;

&lt;h1 id=&#34;preface&#34;&gt;Preface&lt;/h1&gt;

&lt;p&gt;I assume that you are familiar with hash tables and hash table design, as well
as basic terms in concurrent programming.&lt;/p&gt;

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;To be able to actually approach the problem, we have to define a limited API
for the hash table. Here&#39;s the obvious basics:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;insert(key, value)&lt;/code&gt; - for, well, inserting into the table.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;remove(key)&lt;/code&gt; - for removing a entry from the table.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;get(key)&lt;/code&gt; - for querying a value from the table.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are many ways the above set can be expanded, such as iteration, bulk
operations, etc., but we will stick to those for simplicity.&lt;/p&gt;

&lt;h1 id=&#34;the-structure&#34;&gt;The structure&lt;/h1&gt;

&lt;p&gt;As any data structure, you will have the structure (how it is organized, that
is) and the algorithms manipulating it. It is only natural to start by asking:
How should the keys and values be organized?&lt;/p&gt;

&lt;p&gt;There is not really a single answer to that question, but there&#39;s a few things
to keep in mind. First of all, we probably want to avoid reallocation. That
thing is messy, and often impossible, to do atomically; you will almost always
end up introducing some kind of lock, either explicitly or implicitly, so we
must necessarily use a kind of linearly growing structure.&lt;/p&gt;

&lt;p&gt;What if we used some kind of tree?&lt;/p&gt;

&lt;p&gt;If you&#39;ve seen my post about &lt;a href=&#34;https://ticki.github.io/blog/collision-resolution-with-nested-hash-tables/&#34;&gt;nested hash
tables&lt;/a&gt;,
you will know where I&#39;m going, namely that we must organize a tree of tables,
such that extending it, simply means placing a new table at a leaf of the tree.&lt;/p&gt;

&lt;p&gt;The idea is this: Every table has some fixed number of buckets, each of which
can be in one of following states:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Empty - no entry, key, or value.&lt;/li&gt;
&lt;li&gt;Leaf - there is a key and value.&lt;/li&gt;
&lt;li&gt;Branch - the bucket &amp;quot;branches&amp;quot; to another table.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The structure itself is nothing, but a root table. The operations are defined
on any table, and not just the root table, as this allows us to use recursion.&lt;/p&gt;

&lt;p&gt;We&#39;ll see why in a second.&lt;/p&gt;

&lt;h1 id=&#34;the-algorithm&#34;&gt;The algorithm&lt;/h1&gt;

&lt;p&gt;The biggest obstruction to designing concurrent hash table (or hash tables in
general) is of course the collision resolution. When two keys collide (which
will happen with almost certainty), there must be a way of resolving this
collision, meaning to make them able to coexist in the same map.&lt;/p&gt;

&lt;p&gt;In this structure, it is simply done by going from a leaf of the tree to a
branch, containing both key-value pairs (say a bucket is &lt;code&gt;Leaf(entry)&lt;/code&gt; and you
want to insert an entry there called &lt;code&gt;entry2&lt;/code&gt;, then the bucket is changed to
&lt;code&gt;Table(new_table)&lt;/code&gt; where &lt;code&gt;new_table&lt;/code&gt; has both entries; if the two keys still
collide in the new table, repeat).&lt;/p&gt;

&lt;p&gt;The natural question to ask here is how we hash. Surely, if we simply used the
same hash function throughout, a collision would keep happening, even after
branches, as the keys would be assigned the same bucket, over and over again.
Hence, we must choose a way, wherein we can produce distinct hashes for
different tables.&lt;/p&gt;

&lt;p&gt;The easiest way to do this is of course using one of these fancy &amp;quot;seeded hash
functions&amp;quot;, but even that has it&#39;s limitations: What if (like most of these
functions) their independence isn&#39;t mathematically proven? What if there exists
a key which would always generate a collision, despite of the seed? In other
words, it relies on the correctness and quality of the underlying hash
function, which we would like to avoid. In fact, even if we asssumed the
correctness, it would still be suboptimal, due to an unnecessary amount of
collisions, and on top of that, we&#39;d be forced to recalculate the hash for
every table, we traverse. We will come back to another way of producing the
hashes in next section.&lt;/p&gt;

&lt;p&gt;Searching is pretty obvious from here: We simply index by the hash until we
find a leaf or empty bucket, in which case we&#39;re done.&lt;/p&gt;

&lt;p&gt;Lastly, we have deleting, which is simply a matter of replacing a bucket with
&amp;quot;empty&amp;quot;.&lt;/p&gt;

&lt;h1 id=&#34;hashing&#34;&gt;Hashing&lt;/h1&gt;

&lt;p&gt;So, how exactly do we generate the sequence (I say sequence, as in the indexes
for each of the tables in traversing to the entry, namely the sequence of
buckets to follow/jump)?&lt;/p&gt;

&lt;p&gt;Well, we could start by formulating a property of correctness:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given enough elements of the sequence, it shall be possible to reproduce the
hashed value?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Since the sequence is never-ending (and hence has an infinite codomain), this
is possible to satisfy, contrary to classical hash functions, with a finite
codomain.&lt;/p&gt;

&lt;p&gt;Another way of thinking about this is that such function is a function of byte
strings to numbers in the interval, &lt;span  class=&#34;math&#34;&gt;\(\left[0;1\right)\)&lt;/span&gt;. This definition
actually allows us to go one step further and define bijectiveness to create the
ideal of such function.&lt;/p&gt;

&lt;p&gt;Anyway, now that we know what we&#39;re looking for, we must find a way to actually
find it.&lt;/p&gt;

&lt;p&gt;The way I&#39;ve done it is by having a state, which is altering based on the
previous element; and a stack, which contains permuted input.&lt;/p&gt;

&lt;p&gt;The idea is like this: First the stack is populated with the input,
one-byte-by-one. Each byte XOR&#39;d with the state and then permuted by some
table. The generated element is pushed to the stack and is made the state.&lt;/p&gt;

&lt;p&gt;When the stack is populated, elements of the sequence can be read by popping
from the stack, and then permuting the popped element according to the state
(i.e. XOR, then use lookup table). Again, this is set to the state.&lt;/p&gt;

&lt;p&gt;So why exactly this thing? Doesn&#39;t it seem a bit arbitrary?&lt;/p&gt;

&lt;p&gt;Well, there is a reason. First of all, the state is there for bringing in some
context, such that the element in the output can&#39;t simply be predicted
according to the same element in the input.&lt;/p&gt;

&lt;p&gt;Secondly, from the stack, we can reconstruct the input sequence. And from the
output sequence, we can reconstruct the stack, so the input sequence is
reconstructible from the output sequence.&lt;/p&gt;

&lt;p&gt;But why not simply have the output sequence be the stack? Well, without
permuting it after each pop, entropy would only move upwards, i.e. the output
would only depend on the elements &lt;em&gt;before&lt;/em&gt; it in the input. The permutation in
the pop brings in context of the elements &lt;em&gt;after&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;Is this optimal? Probably not, but it&#39;s fine, as it isn&#39;t exactly critical in
performance, kind of like how you don&#39;t optimize command-line parsing in
&lt;code&gt;wget&lt;/code&gt;, the real hit comes from the atomics, not the hashing.&lt;/p&gt;

&lt;h1 id=&#34;making-it-concurrent&#34;&gt;Making it concurrent&lt;/h1&gt;

&lt;p&gt;If you&#39;ve noticed, so far we&#39;ve really only constructed our table in terms of
single-threaded algorithms.&lt;/p&gt;

&lt;p&gt;Maybe it&#39;s obvious to the reader how to make it concurrent, maybe not. It
depends on your experience with things, but I hope the text that follows will
make it sensical to you.&lt;/p&gt;

&lt;p&gt;We can represent each bucket in a node (table) as a pointer, which we only
modify atomically. The null state represents the empty bucket. This allows us
to do certain pretty convenient things.&lt;/p&gt;

&lt;p&gt;Namely, it allows us to use CAS (compare-and-swap) to ensure that the entry,
we&#39;re replacing, is indeed empty. If not, we get the non-matching value, which
allows us to handle things case-by-case.&lt;/p&gt;

&lt;h2 id=&#34;searching&#34;&gt;Searching&lt;/h2&gt;

&lt;p&gt;Searching is painfully obvious: Simply read and follow the appropriate buckets,
until you get to a leaf, which is your final destination. It is a match, if the
key of the leaf matches the key, you&#39;re searching for.&lt;/p&gt;

&lt;h2 id=&#34;insertion&#34;&gt;Insertion&lt;/h2&gt;

&lt;p&gt;As described above, the insert routine starts by effectively CAS-ing the bucket
of the key for null pointers (empty buckets), and replacing with the leaf
containing the key and value, we&#39;re interested in inserting.&lt;/p&gt;

&lt;p&gt;If it failed, we do the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If the bucket is a leaf, try to CAS this bucket pointer to a branching table
containing the leaf&#39;s K/V pair and the pair, we&#39;re inserting. If the CAS
fails, start over with the updated value (see below).&lt;/li&gt;
&lt;li&gt;If the bucket is a table, simply go to that table and insert it there.&lt;/li&gt;
&lt;li&gt;If the bucket is an empty (this means there&#39;ve been an ABA condition; another
thread has removed the value in the meantime), start over with the updated value.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;removal&#34;&gt;Removal&lt;/h2&gt;

&lt;p&gt;Removal is slightly more complicated.&lt;/p&gt;

&lt;p&gt;First, the bucket is read. If it is a subtable, recurse and remove on that.&lt;/p&gt;

&lt;p&gt;If not a table and not empty, then you must CAS for the pointer to the null
pointer. If this fails, one must restart the process (ABA).&lt;/p&gt;

&lt;h1 id=&#34;optional-the-aba-problem&#34;&gt;(Optional:) The ABA problem&lt;/h1&gt;

&lt;p&gt;I&#39;ve mentioned the ABA problem a few times so far, and it turns out to be a
very important issue of concurrent algorithms, but what does it mean?&lt;/p&gt;

&lt;p&gt;In simple terms, it means that some data, we&#39;ve read has changed in the
meantime.&lt;/p&gt;

&lt;p&gt;This is why I don&#39;t read and then write the modified version. Instead I read
&lt;span  class=&#34;math&#34;&gt;\(A\)&lt;/span&gt;, then find &lt;span  class=&#34;math&#34;&gt;\(f(A)\)&lt;/span&gt; and then try to CAS &lt;span  class=&#34;math&#34;&gt;\(A\)&lt;/span&gt; to &lt;span  class=&#34;math&#34;&gt;\(f(A)\)&lt;/span&gt;. It can be a
pain, but it&#39;s necessary. The reason for this is that the atomic, we read as
&lt;span  class=&#34;math&#34;&gt;\(A\)&lt;/span&gt;, could have been changed before or while we evaluated &lt;span  class=&#34;math&#34;&gt;\(f(A)\)&lt;/span&gt;, hence
meaning that &lt;span  class=&#34;math&#34;&gt;\(f(A)\)&lt;/span&gt; would reverse progress another thread has made.&lt;/p&gt;

&lt;p&gt;So the question (to which I have already revealed the answer) is, what happens
if this CAS fails?&lt;/p&gt;

&lt;p&gt;Well, we use a loop. If it fails, we use the new value and repeat our
operation.&lt;/p&gt;

&lt;p&gt;Doesn&#39;t this kind of defeat the point of concurrent algorithms? Well, in a
sense, it does make it non-atomic, but it isn&#39;t really a spin-lock or anything
like that, even though it can seem like that: It doesn&#39;t wait for the data to
be in a state (like a spin-lock will do), it just repeats if the data failed to
be substituted.&lt;/p&gt;

&lt;h1 id=&#34;the-code&#34;&gt;The code&lt;/h1&gt;

&lt;p&gt;It is available
&lt;a href=&#34;https://github.com/redox-os/tfs/tree/master/atomic-hashmap/src&#34;&gt;here&lt;/a&gt;. Note
that it won&#39;t compile out-of-the-box right now, as it relies on some patches I
made to the &lt;code&gt;crossbeam&lt;/code&gt; library. Eventually, I will replace the dependency with
my own replacement for crossbeam.&lt;/p&gt;

&lt;h1 id=&#34;limitations&#34;&gt;Limitations&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;It cannot shrink. Hopefully, this isn&#39;t that big of an issue, given that the
space is reusable, despite not being able to shrink. It is similar to certain
balanced trees, which cannot shrink. In general, the space isn&#39;t lost, nor
leads to unbounded memory usage.&lt;/li&gt;
&lt;li&gt;It is cache suboptimal. This cannot really be avoided. There will, likely, be
more than one cache miss, during traversal. However, the added concurrency
often pays that off performance-wise.&lt;/li&gt;
&lt;li&gt;It relies on some type of concurrent memory reclamation (e.g. hazard
pointers) in order to free memory of removed entries.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Are these worth it? Well, it depends on what you&#39;re doing. In my case, these
are all very much worth it, and I haven&#39;t had any issue with any of them, but
every program is unique and will have its own set of conditions.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>You Are (Probably) Doing Login Systems Wrong</title>
      <link>http://ticki.github.io/blog/you-are-probably-doing-login-systems-wrong/</link>
      <pubDate>Fri, 12 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ticki.github.io/blog/you-are-probably-doing-login-systems-wrong/</guid>
      <description>&lt;p&gt;A thing, most programmers have tried at least once, is login systems. Despite
being seemingly a simple task, it is in fact very hard to do right.&lt;/p&gt;

&lt;p&gt;So, let&#39;s look into, how we can actually do this right.&lt;/p&gt;

&lt;h1 id=&#34;storing-passwords&#34;&gt;Storing passwords&lt;/h1&gt;

&lt;p&gt;Okay, this is common knowledge: Salt and hash your passwords.&lt;/p&gt;

&lt;p&gt;However, it is often done wrong. You&#39;ll see code like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hash(password + salt)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is better than unsalted, unhashed passwords, but it&#39;s far from bruteforce
resistant. Why? Because hashing is cheap. With proper machines, you can do
billions of them in a second. A dictionary attack is piece of cake.&lt;/p&gt;

&lt;p&gt;So how do we solve this? Well, we use a KDF. A KDF (key derivation function)
acts like a slow hash function. A hash function, where calculating takes maybe
100 ms. or more.&lt;/p&gt;

&lt;p&gt;In general, two kinds of KDFs exists, the CPU-based and the CPU-memory hybrids.
The CPU based are still in use, but I don&#39;t recommend using them, as they can
easily be calculated with ASICs. The CPU-memory hybrids requires some amount of
memory for calculating the hash value, often making it substantially harder to
create ASICs.&lt;/p&gt;

&lt;p&gt;For the reasons stated above, I recommend &lt;code&gt;scrypt&lt;/code&gt;, for a modern, well-known
an secure KDF.&lt;/p&gt;

&lt;h1 id=&#34;sessions&#34;&gt;Sessions&lt;/h1&gt;

&lt;p&gt;In general, sessions should be assigned a token by the server. This token is
shared with the client (e.g. through a cookie) as the way to prove, that they
are logged in with a given account to the server.&lt;/p&gt;

&lt;p&gt;There is a few things to keep in mind, though.&lt;/p&gt;

&lt;p&gt;The session token shall have an expiration date, for security reasons.
Furthermore, the session token shall be deactivated when the user logs out.&lt;/p&gt;

&lt;p&gt;One mistake often made in storing the session tokens is to store them in
memory. This is wrong, as it means that crashes or restarts logs every user
out, suspending all sessions. Instead, it ought to be stored in a database,
possibly in a column of the users table.&lt;/p&gt;

&lt;p&gt;Lastly, the session must not be shared through GET or other logged means.
Rather, it should be stored in a cookie or &lt;code&gt;localStorage&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;clientside-hashing&#34;&gt;Client-side hashing&lt;/h1&gt;

&lt;p&gt;A pretty uncommon, but really good practice, is the client-side hashing. It is
supposed act as another layer of security, hiding the password from the server.&lt;/p&gt;

&lt;p&gt;The idea is that the client-side should hash (e.g. &lt;code&gt;scrypt&lt;/code&gt;) the password
before sending it to the server.&lt;/p&gt;

&lt;p&gt;This can seem pretty pointless, as (in the case of the web) the server could
simply change the JavaScript to leak the password, but there is a reason: If
the server-side has a bug that allows to read certain chosen memory locations
(a buffer overflow, for example), it could be exploited to read the plaintext
password.&lt;/p&gt;

&lt;p&gt;Instead, with client-side hashing, it can only read the hashed value. This of
course doesn&#39;t stop the hacker from logging in to the user&#39;s account, but it
stops them from obtaining the potentially reused plain-text password.&lt;/p&gt;

&lt;h1 id=&#34;rate-limiting&#34;&gt;Rate limiting&lt;/h1&gt;

&lt;p&gt;Rate limiting is really, really important, even though it is often understated.
It prevents someone from bruteforcing common passwords.&lt;/p&gt;

&lt;p&gt;But how should the rate limiting work?&lt;/p&gt;

&lt;p&gt;One neat way is the &amp;quot;leaky bucket algorithm&amp;quot;. It works by having requests
&amp;quot;dripping&amp;quot; into a bucket like drops of water. When the leaky bucket is filled,
no more requessts can be made, until the bucket has leaked to empty.&lt;/p&gt;

&lt;p&gt;In less figurative language, you have a counter on every visitor IP address,
which is incremented on every request (e.g. login, create account etc.). When
this counter is above some level (say 5), a timeout is set (e.g. the time when
it expire is set as a field of the user). First when this timeout expires, the
counter resets, and new requests can be made.&lt;/p&gt;

&lt;h1 id=&#34;resetting-accounts&#34;&gt;Resetting accounts&lt;/h1&gt;

&lt;p&gt;Of course a proper system must have the ability to reset accounts. There are
many ways of doing this.&lt;/p&gt;

&lt;p&gt;I would recommend to have the user provide username and E-mail, as it—contrary
to other approaches—does not allow spamming or denial of service attacks. It is
important that you do not reveal whether or not the E-mail matched, as that can
be a breach of privacy of the user (such thing can be used to check if the
E-mail address matched).&lt;/p&gt;

&lt;p&gt;If the E-mail is only going to be used for resetting, I strongly recommend that
you store a fingerprint (e.g. scrypt) of the E-mail address rather than the
plaintext version. This still ensures that you can check if the given E-mail
address of the resetting user matches, without the server side knowing anything
about the address. It prevents the database being misused or sold for spam
purposes, and also helps to protect the user&#39;s identity.&lt;/p&gt;

&lt;p&gt;When the user resets, a token shall be generated. This token is used in a link,
sent to the user through an E-mail. It is important that this token is
sufficiently long, random, and furthermore, that it expires (ideally within only
a few hours).&lt;/p&gt;

&lt;p&gt;Note that upon resetting, the token should removed from the map.&lt;/p&gt;

&lt;h1 id=&#34;other-tips&#34;&gt;Other tips&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Consider implementing a common two-factor key-sharing algorithm, such as
&lt;a href=&#34;https://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm&#34;&gt;TOTP&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;I recommend that changing E-mail and password are done under the &amp;quot;reset
password&amp;quot; formula, such that E-mail confirmation is required.&lt;/li&gt;
&lt;li&gt;It is extremely important that the connection, where the login happens is
secure, for example &lt;code&gt;https&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Well, that&#39;s it.&lt;/p&gt;

&lt;p&gt;You have to be careful about what you do, though. This is a minefield of
vulnerabilities, and you have to be very careful not to introduce subtle bugs
in your code. I recommend that you let somebody other than yourself review your
code, to give you another&#39;s perspective on the code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Portfolio of Logos and Icons</title>
      <link>http://ticki.github.io/blog/portfolio-of-logos-and-icons/</link>
      <pubDate>Mon, 19 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://ticki.github.io/blog/portfolio-of-logos-and-icons/</guid>
      <description>&lt;p&gt;This is a collection of the logos and icons, I created (and used/not drafts) during the last years.&lt;/p&gt;

&lt;h1 id=&#34;opensea&#34;&gt;Open-Sea&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ticki/Open-Sea&#34;&gt;Open Sea&lt;/a&gt; is a dead game project I was working on:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;figure&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ticki/Open-Sea/master/data/graphics/logo_scaled.png&#34; alt=&#34;Open-Sea logo&#34;&gt;&lt;/figure&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;Simple pixel art.&lt;/li&gt;
&lt;li&gt;Stylistic and minimalistic text.&lt;/li&gt;
&lt;li&gt;Simple icon similar to the graphics in the game.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;redox&#34;&gt;Redox&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/redox-os&#34;&gt;Redox&lt;/a&gt; is an operating-system I work on. The icon was one of the first things I contributed to Redox (before code):&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;figure&gt;&lt;img src=&#34;https://rawgit.com/redox-os/assets/master/vectorized_icon.svg&#34; alt=&#34;Redox vectorized icon&#34;&gt;&lt;/figure&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;It is a circle construction formed after an atom.&lt;/li&gt;
&lt;li&gt;The electrons are placed to resemble a sodium atom, which together with e.g. fluorine reacts in a redox reaction.&lt;/li&gt;
&lt;li&gt;It&#39;s SVG!&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;sodium&#34;&gt;Sodium&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/redox-os/sodium&#34;&gt;Sodium&lt;/a&gt; is a text editor I wrote. The logo is&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;img src=&#34;https://raw.githubusercontent.com/redox-os/assets/master/Sodium_logo.png&#34; height=&#34;200&#34; width=&#34;200&#34; /&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;It is based on a basic square with rounded edges (square construction).&lt;/li&gt;
&lt;li&gt;It uses text as a form of background noise.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;xenotime&#34;&gt;XENOTIME&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/neon-sector/xenotime&#34;&gt;XENOTIME&lt;/a&gt; is a game engine, which I created a logo for:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;img src=&#34;https://raw.githubusercontent.com/neon-sector/xenotime/master/res/xenotime/logo.png&#34; height=&#34;200&#34; width=&#34;200&#34; /&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;It is a text-based logo.&lt;/li&gt;
&lt;li&gt;It uses red-black colorscheme because it reflects the colorful game world.&lt;/li&gt;
&lt;li&gt;It preserves simplicity.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;tfs&#34;&gt;TFS&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ticki/tfs&#34;&gt;TFS&lt;/a&gt; is a filesystem I&#39;m working on. The icon is:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;figure&gt;&lt;img src=&#34;https://rawgit.com/ticki/tfs/master/icon.svg&#34; alt=&#34;TFS icon&#34;&gt;&lt;/figure&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;It is a hexagone looking like an isometric projection of a cube, giving it a 3D feel.&lt;/li&gt;
&lt;li&gt;The tetragon gives it a &amp;quot;glassy&amp;quot; feel (looking modern).&lt;/li&gt;
&lt;li&gt;One of my favorite logo creations.&lt;/li&gt;
&lt;li&gt;Just 284 bytes, in total (optimized SVG). Compressed, it is around 100 bytes.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;seahash&#34;&gt;SeaHash&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ticki/tfs/tree/master/seahash&#34;&gt;SeaHash&lt;/a&gt; is a hash function I designed:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;img src=&#34;https://raw.githubusercontent.com/ticki/tfs/master/seahash/logo.png&#34; height=&#34;200&#34; width=&#34;200&#34; /&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;Very simple and not so fancy (showing stability and robustness).&lt;/li&gt;
&lt;li&gt;Waves symbolizing the sea and performance.&lt;/li&gt;
&lt;li&gt;Basic monospace font.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;termion&#34;&gt;Termion&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ticki/termion&#34;&gt;Termion&lt;/a&gt; is a terminal manipulation library I wrote:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;a href=&#34;https://rawgit.com/ticki/termion/master/logo.svg&#34;&gt;&lt;figure&gt;&lt;img src=&#34;https://rawgit.com/ticki/termion/master/logo.svg&#34; alt=&#34;Termion logo&#34;&gt;&lt;/figure&gt;&lt;/a&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;It&#39;s animated, which is really cool. Note that in some browsers, the animation doesn&#39;t work in IMG tags, so if it is static, click it.&lt;/li&gt;
&lt;li&gt;The animation gives it an &amp;quot;interactive&amp;quot; feel.&lt;/li&gt;
&lt;li&gt;It uses common terminal colors and font.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;tip-of-the-iceberg&#34;&gt;Tip of the iceberg&lt;/h1&gt;

&lt;p&gt;These are just the ones I used. I&#39;ve created many other drafts and candidates, which I might show in another blog post.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>