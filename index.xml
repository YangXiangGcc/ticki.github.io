<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ticki&#39;s blog</title>
    <link>http://ticki.github.io/</link>
    <description>Recent content on Ticki&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 09 Aug 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://ticki.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>On the Controversial Google Manifesto</title>
      <link>http://ticki.github.io/blog/on-the-controversial-google-manifesto/</link>
      <pubDate>Wed, 09 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ticki.github.io/blog/on-the-controversial-google-manifesto/</guid>
      <description>The infamous manifesto from the (now former) Google employee has made its round on the internet. It alleges an ideological ecochamber and overly commitment to diversity on the work place, as well as reverse discrimination and the alike. He claims that the inequalities are not necessarily due to discrimination but presumably biological differences.
When he says things like that - especially when he spreads these ideas, he actively supports a culture already existing, where women are vastly underrepresented - without making a proper case of why.</description>
    </item>
    
    <item>
      <title>Fearless concurrency with hazard pointers</title>
      <link>http://ticki.github.io/blog/fearless-concurrency-with-hazard-pointers/</link>
      <pubDate>Wed, 02 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ticki.github.io/blog/fearless-concurrency-with-hazard-pointers/</guid>
      <description>For those who don&#39;t know, I am working on a file system, TFS, which employs various concurrent structures to improve performance. Whenever you do this kind of advanced concurrency, you will meet the ABA problem, roughly describable as &amp;quot;what if another thread runs the destructor on a value you are reading?&amp;quot;
What this problem is, and how can it be solved, is what this blog post will investigate. It presents a form of an optimized form of hazard-pointers as well as an implementation thereof.</description>
    </item>
    
    <item>
      <title>The Case for Non-Binary Genders</title>
      <link>http://ticki.github.io/blog/the-case-for-non-binary-genders/</link>
      <pubDate>Sat, 24 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ticki.github.io/blog/the-case-for-non-binary-genders/</guid>
      <description>Recently, there has been a lot of discussion around this topic. Is the two genders scientific? No, yes?
To be fair, if you are someone, who has never met a non-binary person, you will probably be pretty confused, given that there is a lot of pseudo-scientific, gaslighting disinformation out there.
So, what is the case for non-binary genders really?
The philosophical case for non-binary genders The mere existence of NB (people identifying as non-binary gendered) should itself justify their recognition.</description>
    </item>
    
    <item>
      <title>Setting up ArchLinux on a Lenovo Yoga</title>
      <link>http://ticki.github.io/blog/setting-up-archlinux-on-a-lenovo-yoga/</link>
      <pubDate>Tue, 30 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ticki.github.io/blog/setting-up-archlinux-on-a-lenovo-yoga/</guid>
      <description>So, I recently broke my computer by spilling tea unto it, so I needed a new computer, and found the Lenovo Yoga 710, which is pretty lightweight and yet strong. As the resources on installing Linux (ArchLinux specifically) on this machine are barely existing, I thought I had to make this post, explaining various critical thing about the installation.
Bear in mind that all this is made from notes and what I recall from when I installed it (yesterday), so there might be minor inaccuracies.</description>
    </item>
    
    <item>
      <title>An Atomic Hash Table</title>
      <link>http://ticki.github.io/blog/an-atomic-hash-table/</link>
      <pubDate>Sat, 13 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ticki.github.io/blog/an-atomic-hash-table/</guid>
      <description>In programs where there is some kind of global state, you will often find the need for having a key-value map; you could for example imagine keeping some kind of cache of a bunch of entries from database table. Obviously, you&#39;d just use a hash table, easy right?
Not really. Imagine that there is multiple threads. One approach is to wrap it in a mutex to ensure thread safety, but that would kind of miss the point of concurrency: It wouldn&#39;t be concurrent, it would just be blocking.</description>
    </item>
    
    <item>
      <title>You Are (Probably) Doing Login Systems Wrong</title>
      <link>http://ticki.github.io/blog/you-are-probably-doing-login-systems-wrong/</link>
      <pubDate>Fri, 12 May 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ticki.github.io/blog/you-are-probably-doing-login-systems-wrong/</guid>
      <description>A thing, most programmers have tried at least once, is login systems. Despite being seemingly a simple task, it is in fact very hard to do right.
So, let&#39;s look into, how we can actually do this right.
Storing passwords Okay, this is common knowledge: Salt and hash your passwords.
However, it is often done wrong. You&#39;ll see code like:
hash(password + salt)  This is better than unsalted, unhashed passwords, but it&#39;s far from bruteforce resistant.</description>
    </item>
    
    <item>
      <title>The Lazy Argument of Human Nature</title>
      <link>http://ticki.github.io/blog/the-lazy-argument-of-human-nature/</link>
      <pubDate>Wed, 19 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ticki.github.io/blog/the-lazy-argument-of-human-nature/</guid>
      <description>When you discuss socialism, you are guaranteed to hear someone say &amp;quot;socialism won&#39;t work because of human nature&amp;quot;. This argument is particularly lazy, but I keep hearing it, so I wanted to address it in my own words.
What the argument entails It is incredibly vague, but it usually goes something like
 Greed and selfishness is an essential part of human nature, hence socialism will fail.
 It often follows that capitalism is the only system that works.</description>
    </item>
    
    <item>
      <title>A general construction for rolling hash functions</title>
      <link>http://ticki.github.io/blog/a-general-construction-for-rolling-hash-functions/</link>
      <pubDate>Thu, 02 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ticki.github.io/blog/a-general-construction-for-rolling-hash-functions/</guid>
      <description>What is a rolling hash function? A hash function is a function \(h : S^\times \to F\) with \(S, F\) being some finite sets.
A rolling hash function is really a set of functions \((h, u)\), where \(u\) allows retroactively updated a symbol
\[h(\ldots a \ldots) \mapsto h(\ldots a&#39; \ldots)\]
To put it more formally, a rolling hash function has an associated function \(u : F \times S^2 \times \mathbb N \to F\), satisfying</description>
    </item>
    
    <item>
      <title>Collision Resolution with Nested Hash Tables</title>
      <link>http://ticki.github.io/blog/collision-resolution-with-nested-hash-tables/</link>
      <pubDate>Thu, 16 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://ticki.github.io/blog/collision-resolution-with-nested-hash-tables/</guid>
      <description>Collision resolution Hash collisions in hash tables are unevitable, and therefore every proper implementation needs a form of collision resolution. Collision resolution is the name of the class of algorithms and techniques used to organize and resolve the case where two entries in the table hash to the same bucket.
It turns out that the choice and implementation of collision resolution is absolutely critical for the performance of the table, because while hash tables are often mistaken for having \(O(1)\) lookups, they do in reality and theory have a sligthly more complicated behavior.</description>
    </item>
    
    <item>
      <title>Portfolio of Logos and Icons</title>
      <link>http://ticki.github.io/blog/portfolio-of-logos-and-icons/</link>
      <pubDate>Mon, 19 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://ticki.github.io/blog/portfolio-of-logos-and-icons/</guid>
      <description>This is a collection of the logos and icons, I created (and used/not drafts) during the last years.
Open-Sea Open Sea is a dead game project I was working on:
          Simple pixel art. Stylistic and minimalistic text. Simple icon similar to the graphics in the game.  Redox Redox is an operating-system I work on. The icon was one of the first things I contributed to Redox (before code):</description>
    </item>
    
    <item>
      <title>The Eudex Algorithm</title>
      <link>http://ticki.github.io/blog/the-eudex-algorithm/</link>
      <pubDate>Sun, 11 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://ticki.github.io/blog/the-eudex-algorithm/</guid>
      <description>Half a year ago, I designed Eudex as a modern replacement for Soundex, which is still widely used today. Eudex supports a wide range of special-cases of European languages, while preserving the spirit of simplicity, Soundex has.
Both Eudex and Soundex are phonetic algorithms that produce a representation of the sound of some string. Eudex is fundamentally different from Soundex in that it is not a phonetic classifier. It is a phonetic locality-sensitive hash, which means that two similarly-sounding strings are not mapped to the same value, but instead to values near to each other.</description>
    </item>
    
    <item>
      <title>SeaHash: Explained</title>
      <link>http://ticki.github.io/blog/seahash-explained/</link>
      <pubDate>Thu, 08 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://ticki.github.io/blog/seahash-explained/</guid>
      <description>So, not so long ago, I designed SeaHash, an alternative hash algorithm with performance better than most (all?) of the existing non-cryptographic hash functions available. I designed it for checksumming for a file system, I&#39;m working on, but I quickly found out it was sufficient for general hashing.
It blew up. I got a lot of cool feedback, and yesterday it was picked as crate of the week. It shows that there is some interest in it, so I want to explain the ideas behind it.</description>
    </item>
    
    <item>
      <title>Ternary as a prediction residue code</title>
      <link>http://ticki.github.io/blog/ternary-as-a-prediction-residue-code/</link>
      <pubDate>Fri, 11 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://ticki.github.io/blog/ternary-as-a-prediction-residue-code/</guid>
      <description>If we look at how most lossless image compression formats works, they don&#39;t use deduplication compression (like LZ-class algorithms), because that&#39;s simply far from the nature of images. The same goes for audio and video. Instead, you have two maps:
 The approximative map (\(a(\vec{v})\)): This should give a rough outline of the medium, that is, it is should predict predict the medium based on a small sequence of bytes (defined by the encoding).</description>
    </item>
    
    <item>
      <title>What we learned from the election results</title>
      <link>http://ticki.github.io/blog/what-we-have-learned-from-the-election-results/</link>
      <pubDate>Wed, 09 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://ticki.github.io/blog/what-we-have-learned-from-the-election-results/</guid>
      <description>It was a surprising and intense outcome to watch yesterday night. As you probably know by now, Trump won, contrary to all predictions and calls.
But why?
I&amp;rsquo;m not an US citzen, but I have followed the race with great passion, and I want to give my outsider two-cents on &amp;lsquo;what the hell is going&amp;rsquo; in United States of America.
So, what did we actually learn?
1. USA is a post-fact society Many of the things Trump have said are lies, and it is often trivial to prove so.</description>
    </item>
    
    <item>
      <title>Designing a good non-cryptographic hash function</title>
      <link>http://ticki.github.io/blog/designing-a-good-non-cryptographic-hash-function/</link>
      <pubDate>Fri, 04 Nov 2016 16:28:44 +0200</pubDate>
      
      <guid>http://ticki.github.io/blog/designing-a-good-non-cryptographic-hash-function/</guid>
      <description>So, I&#39;ve been needing a hash function for various purposes, lately. None of the existing hash functions I could find were sufficient for my needs, so I went and designed my own. These are my notes on the design of hash functions.
What is a hash function really? Hash functions are functions which maps a infinite domain to a finite codomain. Two elements in the domain, \(a, b\) are said to collide if \(h(a) = h(b)\).</description>
    </item>
    
    <item>
      <title>How LZ4 works</title>
      <link>http://ticki.github.io/blog/how-lz4-works/</link>
      <pubDate>Tue, 25 Oct 2016 23:25:15 +0200</pubDate>
      
      <guid>http://ticki.github.io/blog/how-lz4-works/</guid>
      <description>LZ4 is a really fast compression algorithm with a reasonable compression ratio, but unfortunately there is limited documentation on how it works. The only explanation (not spec, explanation) can be found on the author&#39;s blog, but I think it is less of an explanation and more of an informal specification.
This blog post tries to explain it such that anybody (even new beginners) can understand and implement it.
Linear small-integer code (LSIC) The first part of LZ4 we need to explain is a smart but simple integer encoder.</description>
    </item>
    
    <item>
      <title>On Random-Access Compression</title>
      <link>http://ticki.github.io/blog/on-random-access-compression/</link>
      <pubDate>Sun, 23 Oct 2016 23:25:15 +0200</pubDate>
      
      <guid>http://ticki.github.io/blog/on-random-access-compression/</guid>
      <description>This post will contains an algorithm I came up with, doing efficient rolling compression. It&#39;s going to be used in TFS.
What is rolling compression? Consider that you have a large file and you want to compress it. That&#39;s easy enough and many algorithms exists for doing so. Now, consider that you want to read or write a small part of the file.
Most algorithms would require you to decompress, write, and recompress the whole file.</description>
    </item>
    
    <item>
      <title>Making Terminal Applications in Rust with Termion</title>
      <link>http://ticki.github.io/blog/making-terminal-applications-in-rust-with-termion/</link>
      <pubDate>Thu, 06 Oct 2016 10:12:22 +0200</pubDate>
      
      <guid>http://ticki.github.io/blog/making-terminal-applications-in-rust-with-termion/</guid>
      <description>This post will walk through the basics of implementing a terminal (TTY) application for both new beginners and experienced users of Rust.
Introduction Terminal applications play an important role in many programmers&amp;rsquo; toolchain, from text editors to minigames while your code is compiling. And it&amp;rsquo;s great to know and understand how to make these yourself, so you can create a customized TUI application for your needs.
Escape codes and TTY I/O is messy, but fortunately there are libraries for this.</description>
    </item>
    
    <item>
      <title>A Hoare Logic for Rust</title>
      <link>http://ticki.github.io/blog/a-hoare-logic-for-rust/</link>
      <pubDate>Sat, 24 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://ticki.github.io/blog/a-hoare-logic-for-rust/</guid>
      <description>Lately, I&#39;ve been working on a Hoare-logic-based model of the Rust MIR, which I will introduce in the post. This is a minor step towards a memory model of Rust, and it allows formalization of programs and their behavior.
This project was born out of the effort to formalize the Redox kernel and the ralloc memory allocator as well as coming up with a Rust memory model.
Here I will walk through the techniques, axioms, and transformations in detail.</description>
    </item>
    
    <item>
      <title>Skip Lists: Done Right</title>
      <link>http://ticki.github.io/blog/skip-lists-done-right/</link>
      <pubDate>Sat, 17 Sep 2016 13:46:49 +0200</pubDate>
      
      <guid>http://ticki.github.io/blog/skip-lists-done-right/</guid>
      <description>What is a skip list? In short, skip lists are a linked-list-like structure which allows for fast search. It consists of a base list holding the elements, together with a tower of lists maintaining a linked hierarchy of subsequences, each skipping over fewer elements.
Skip list is a wonderful data structure, one of my personal favorites, but a trend in the past ten years has made them more and more uncommon as a single-threaded in-memory structure.</description>
    </item>
    
    <item>
      <title>About me</title>
      <link>http://ticki.github.io/about/</link>
      <pubDate>Wed, 14 Sep 2016 22:50:08 +0200</pubDate>
      
      <guid>http://ticki.github.io/about/</guid>
      <description>I&amp;rsquo;m Ticki, this blog is about programming, mathematics, and politics.
People in the Rust community might know my for Redox OS, Termion, and the Π-type RFC. I&amp;rsquo;m the author of Ralloc, TFS, and SeaHash as well.
My primary interests are abstract algebra (most field theory and Galois theory), OS development, algorithms, and type systems.
I enjoy music, and especially classical music. My favorite classical composers are Chopin, Lizst, Debussy, and Satie (in that order).</description>
    </item>
    
    <item>
      <title>Why Rust&#39;s `std::collections` is absolutely fantastic</title>
      <link>http://ticki.github.io/blog/fantastic/</link>
      <pubDate>Wed, 14 Sep 2016 16:07:34 +0200</pubDate>
      
      <guid>http://ticki.github.io/blog/fantastic/</guid>
      <description>My last blog post was about all the short-fallings and problems std::collections has. This post will be about the opposite: all the good things about std::collections and what other languages can learn from Rust.
This post is a part of an on-going series of posts criticizing and praising various parts of Rust.
The philosophy of std::collections Rust has an intentionally small set of collections. This has both advantages and disadvantages.</description>
    </item>
    
    <item>
      <title>A Critique of Rust&#39;s `std::collections`</title>
      <link>http://ticki.github.io/blog/horrible/</link>
      <pubDate>Mon, 12 Sep 2016 22:50:08 +0200</pubDate>
      
      <guid>http://ticki.github.io/blog/horrible/</guid>
      <description>Rust is by far my favorite language, and I am very familiar with it, but there is one aspect that annoys me at times: std::collections, a part of the opt-out standard library.
This post will go through the short-fallings of the API and implementation of std::collections. I&amp;rsquo;ll try to present alternatives and way to improve it.
Update: The title was previously &amp;ldquo;Why std::collections is absolutely horrible&amp;rdquo;. It was in the hope to spark critical discussion, however people were rather annoyed by this title (and I understand why), so I changed it to something less provocative.</description>
    </item>
    
    <item>
      <title>Lambda crabs (part 3): Region-based alias analysis</title>
      <link>http://ticki.github.io/blog/lambda-crabs-part-3-region-based-alias-analysis/</link>
      <pubDate>Wed, 08 Jun 2016 11:24:24 +0200</pubDate>
      
      <guid>http://ticki.github.io/blog/lambda-crabs-part-3-region-based-alias-analysis/</guid>
      <description>In the last post, we saw how to infer regions and their span. In this post, we will cover aliasing and how to ensure guarantees through region analysis.
Aliasing, mutable aliasing, and unsafety. Two pointers are said to be aliased, if they refer to the same object. Alias analysis is essential to program verification, optimizers, and compiler theory.
Alias analysis is the study of which pointers are aliased and, more importantly, which pointers aren&amp;rsquo;t aliased.</description>
    </item>
    
    <item>
      <title>Lambda crabs (part 2): Region inference is (not) magic.</title>
      <link>http://ticki.github.io/blog/lambda-crabs-part-2-region-inference-is-not-magic./</link>
      <pubDate>Mon, 06 Jun 2016 11:06:21 +0200</pubDate>
      
      <guid>http://ticki.github.io/blog/lambda-crabs-part-2-region-inference-is-not-magic./</guid>
      <description>This post will cover region (lifetime) inference with a mathematical and type theoretical focus.
The problem Inference is a very handy concept. We no longer have to annotate redundant types, which is a major pain point in languages, that lacks of type inference.
Now, we want such an inference scheme for regions as well.
We described the problem of region inference in last post as:
 So, this is just a classical optimization problem:</description>
    </item>
    
    <item>
      <title>Lambda crabs (part 1): A mathematical introduction to lifetimes and regions</title>
      <link>http://ticki.github.io/blog/lambda-crabs-part-1-a-mathematical-introduction-to-lifetimes-and-regions/</link>
      <pubDate>Mon, 06 Jun 2016 09:12:56 +0200</pubDate>
      
      <guid>http://ticki.github.io/blog/lambda-crabs-part-1-a-mathematical-introduction-to-lifetimes-and-regions/</guid>
      <description>This post will cover lifetimes and regions in depth, with a focus on the mathematical background of regions. That is, what is a region? What rules do they follow? How does the compiler handle them? And how are they inferred?
Regions and their ordering So, let&amp;rsquo;s briefly investigate what a region is. A region (or in Rust lingo, a lifetime) is a span of some form, e.g. the token stream.</description>
    </item>
    
  </channel>
</rss>